<!doctype html>
<html lang="en" data-theme="system" data-accent="orange">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ARIA Patterns in React: Complete Beginner's Guide (2026)</title>
    <link
      rel="icon"
      type="image/x-icon"
      href="../assets/icons/suprabhat-favicon.png"
    />

    <meta
      name="description"
      content="Master ARIA patterns in React with simple examples. Learn roles, states, and properties to make your React apps accessible to everyone."
    />
    <meta name="theme-color" content="#f28c28" />
    <meta name="author" content="Suprabhat Kumar" />
    <meta
      name="keywords"
      content="aria patterns, aria attributes react, aria roles, accessible react, aria examples, screen reader react, aria states, aria properties, web accessibility"
    />
    <meta name="robots" content="index, follow" />
    <link
      rel="canonical"
      href="https://suprabhat-portfolio.netlify.app/blog/aria-patterns-react-guide.html"
    />

    <!-- Open Graph -->
    <meta
      property="og:title"
      content="ARIA Patterns in React: Complete Beginner's Guide (2026)"
    />
    <meta
      property="og:description"
      content="Master ARIA patterns in React with simple examples. Learn roles, states, and properties to make your React apps accessible to everyone."
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://suprabhat-portfolio.netlify.app/blog/aria-patterns-react-guide.html"
    />
    <meta property="article:published_time" content="2026-02-06" />
    <meta property="article:author" content="Suprabhat Kumar" />
    <meta property="article:section" content="Accessibility" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:title"
      content="ARIA Patterns in React: Complete Beginner's Guide"
    />
    <meta
      name="twitter:description"
      content="Learn ARIA patterns in React with practical examples for beginners."
    />
    <meta name="twitter:creator" content="@suprabhat" />

    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;600;700&display=swap"
      rel="stylesheet"
    />

    <style>
      :root {
        color-scheme: light dark;
      }
      html {
        scroll-behavior: smooth;
        font-size: 100%;
      }
      body {
        margin: 0;
        font-family:
          "Inconsolata",
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
        background: var(--color-bg-primary);
        color: var(--color-text-primary);
        line-height: 1.6;
      }
      :focus-visible {
        outline: 0.1875rem solid var(--color-orange-500);
        outline-offset: 0.25rem;
      }
      .container {
        max-width: 72rem;
        margin: 0 auto;
        padding: 0.625rem 1.5rem;
      }
    </style>

    <link rel="stylesheet" href="../styles/main.css" />
  </head>
  <body>
    <!-- Header component placeholder -->
    <div id="header-placeholder"></div>

    <!-- Mobile menu component placeholder -->
    <div id="mobile-menu-placeholder"></div>

    <main id="main">
      <article class="blog-post-header section">
        <div class="container">
          <a href="../blog.html" class="blog-back-link">
            <svg viewBox="0 0 20 20" fill="currentColor">
              <path
                fill-rule="evenodd"
                d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z"
                clip-rule="evenodd"
              />
            </svg>
            Back to Blog
          </a>
          <div class="blog-post-meta">
            <time datetime="2026-02-06">February 6, 2026</time>
            <span class="blog-post-category">Accessibility</span>
            <span>8 min read</span>
          </div>
          <h1>ARIA Patterns in React: Complete Beginner's Guide</h1>
        </div>
      </article>

      <section class="blog-post-content">
        <div class="container">
          <p>
            ARIA (Accessible Rich Internet Applications) makes your React apps
            work for everyone, including users with disabilities. In this guide,
            you'll learn the most common ARIA patterns with real React
            examples‚Äîfrom tabs and accordions to dropdowns and modals. Let's
            make your apps truly accessible!
          </p>

          <h2>What is ARIA and Why Does It Matter?</h2>

          <p>
            ARIA is a set of attributes that define ways to make web content
            more accessible. Think of ARIA as a translator between your complex
            React components and assistive technologies like screen readers.
          </p>

          <ul>
            <li>
              <strong>Roles</strong> - Define what an element is (button, tab,
              dialog)
            </li>
            <li>
              <strong>States</strong> - Describe the current condition (checked,
              expanded, selected)
            </li>
            <li>
              <strong>Properties</strong> - Provide additional information
              (label, description, controls)
            </li>
          </ul>

          <blockquote>
            <strong>First Rule of ARIA:</strong> Don't use ARIA if you can use
            semantic HTML instead. Use <code>&lt;button&gt;</code> before
            <code>&lt;div role="button"&gt;</code>.
          </blockquote>

          <h2>Pattern 1: Accessible Tabs</h2>

          <p>
            Tabs are one of the most common UI patterns. Here's how to make them
            accessible:
          </p>

          <pre><code>import React, { useState, useRef, useEffect } from 'react';

function AccessibleTabs({ tabs }) {
  const [activeTab, setActiveTab] = useState(0);
  const tabRefs = useRef([]);

  // Keyboard navigation
  const handleKeyDown = (event, index) => {
    const { key } = event;
    let newIndex = index;

    if (key === 'ArrowRight') {
      newIndex = (index + 1) % tabs.length;
    } else if (key === 'ArrowLeft') {
      newIndex = (index - 1 + tabs.length) % tabs.length;
    } else if (key === 'Home') {
      newIndex = 0;
    } else if (key === 'End') {
      newIndex = tabs.length - 1;
    } else {
      return; // Don't prevent default for other keys
    }

    event.preventDefault();
    setActiveTab(newIndex);
    tabRefs.current[newIndex]?.focus();
  };

  return (
    &lt;div className="tabs"&gt;
      {/* Tab list with proper ARIA attributes */}
      &lt;div role="tablist" aria-label="Content sections"&gt;
        {tabs.map((tab, index) => (
          &lt;button
            key={tab.id}
            ref={(el) => (tabRefs.current[index] = el)}
            role="tab"
            aria-selected={activeTab === index}
            aria-controls={`panel-${tab.id}`}
            id={`tab-${tab.id}`}
            tabIndex={activeTab === index ? 0 : -1}
            onClick={() => setActiveTab(index)}
            onKeyDown={(e) => handleKeyDown(e, index)}
            className={activeTab === index ? 'active' : ''}
          &gt;
            {tab.label}
          &lt;/button&gt;
        ))}
      &lt;/div&gt;

      {/* Tab panels */}
      {tabs.map((tab, index) => (
        &lt;div
          key={tab.id}
          role="tabpanel"
          id={`panel-${tab.id}`}
          aria-labelledby={`tab-${tab.id}`}
          hidden={activeTab !== index}
          tabIndex={0}
        &gt;
          {tab.content}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Usage
function App() {
  const tabs = [
    { id: 'about', label: 'About', content: &lt;p&gt;About content&lt;/p&gt; },
    { id: 'services', label: 'Services', content: &lt;p&gt;Services content&lt;/p&gt; },
    { id: 'contact', label: 'Contact', content: &lt;p&gt;Contact content&lt;/p&gt; },
  ];

  return &lt;AccessibleTabs tabs={tabs} /&gt;;
}</code></pre>

          <h3>Key ARIA Attributes for Tabs:</h3>

          <ul>
            <li><code>role="tablist"</code> - Container for tabs</li>
            <li><code>role="tab"</code> - Individual tab button</li>
            <li><code>role="tabpanel"</code> - Content panel</li>
            <li><code>aria-selected</code> - Indicates active tab</li>
            <li><code>aria-controls</code> - Links tab to its panel</li>
            <li><code>aria-labelledby</code> - Links panel to its tab</li>
            <li>
              <code>tabIndex={-1}</code> - Removes inactive tabs from tab order
            </li>
          </ul>

          <h2>Pattern 2: Accordion Component</h2>

          <p>
            Accordions hide and show content. Here's the accessible way to build
            them:
          </p>

          <pre><code>import React, { useState } from 'react';

function AccordionItem({ title, content, isOpen, onToggle, id }) {
  const headerId = `accordion-header-${id}`;
  const panelId = `accordion-panel-${id}`;

  return (
    &lt;div className="accordion-item"&gt;
      &lt;h3&gt;
        &lt;button
          id={headerId}
          aria-expanded={isOpen}
          aria-controls={panelId}
          onClick={onToggle}
          className="accordion-button"
        &gt;
          &lt;span&gt;{title}&lt;/span&gt;
          &lt;svg
            aria-hidden="true"
            className={`icon ${isOpen ? 'rotate' : ''}`}
            viewBox="0 0 24 24"
          &gt;
            &lt;path d="M19 9l-7 7-7-7" /&gt;
          &lt;/svg&gt;
        &lt;/button&gt;
      &lt;/h3&gt;
      
      &lt;div
        id={panelId}
        role="region"
        aria-labelledby={headerId}
        hidden={!isOpen}
        className="accordion-panel"
      &gt;
        {content}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

function Accordion({ items, allowMultiple = false }) {
  const [openItems, setOpenItems] = useState(new Set([0]));

  const toggleItem = (index) => {
    setOpenItems((prev) => {
      const newSet = allowMultiple ? new Set(prev) : new Set();
      if (prev.has(index)) {
        newSet.delete(index);
      } else {
        newSet.add(index);
      }
      return newSet;
    });
  };

  return (
    &lt;div className="accordion"&gt;
      {items.map((item, index) => (
        &lt;AccordionItem
          key={index}
          id={index}
          title={item.title}
          content={item.content}
          isOpen={openItems.has(index)}
          onToggle={() => toggleItem(index)}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}

// Usage
const faqItems = [
  { title: 'What is React?', content: 'React is a JavaScript library...' },
  { title: 'What is ARIA?', content: 'ARIA stands for...' },
  { title: 'Why accessibility?', content: 'Accessibility ensures...' },
];

&lt;Accordion items={faqItems} allowMultiple={true} /&gt;</code></pre>

          <h3>Key ARIA Attributes for Accordions:</h3>

          <ul>
            <li>
              <code>aria-expanded</code> - Shows if panel is open or closed
            </li>
            <li>
              <code>aria-controls</code> - Links button to panel it controls
            </li>
            <li>
              <code>role="region"</code> - Identifies the expandable content
            </li>
            <li><code>aria-labelledby</code> - Connects panel to its header</li>
            <li>
              <code>hidden</code> - Hides panel from screen readers when closed
            </li>
          </ul>

          <h2>Pattern 3: Dropdown Menu</h2>

          <p>
            Dropdowns require careful ARIA implementation for proper screen
            reader support:
          </p>

          <pre><code>import React, { useState, useRef, useEffect } from 'react';

function Dropdown({ label, items }) {
  const [isOpen, setIsOpen] = useState(false);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const buttonRef = useRef(null);
  const menuRef = useRef(null);
  const itemRefs = useRef([]);

  // Close on outside click
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (
        menuRef.current &&
        !menuRef.current.contains(event.target) &&
        !buttonRef.current.contains(event.target)
      ) {
        setIsOpen(false);
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  const handleKeyDown = (event) => {
    const { key } = event;

    if (key === 'Escape') {
      setIsOpen(false);
      buttonRef.current?.focus();
      return;
    }

    if (!isOpen) {
      if (key === 'ArrowDown' || key === 'Enter' || key === ' ') {
        event.preventDefault();
        setIsOpen(true);
        setFocusedIndex(0);
      }
      return;
    }

    // Menu is open
    let newIndex = focusedIndex;

    if (key === 'ArrowDown') {
      event.preventDefault();
      newIndex = (focusedIndex + 1) % items.length;
    } else if (key === 'ArrowUp') {
      event.preventDefault();
      newIndex = (focusedIndex - 1 + items.length) % items.length;
    } else if (key === 'Home') {
      event.preventDefault();
      newIndex = 0;
    } else if (key === 'End') {
      event.preventDefault();
      newIndex = items.length - 1;
    } else if (key === 'Enter' || key === ' ') {
      event.preventDefault();
      if (focusedIndex >= 0) {
        handleItemClick(items[focusedIndex]);
      }
      return;
    }

    setFocusedIndex(newIndex);
  };

  useEffect(() => {
    if (isOpen && focusedIndex >= 0) {
      itemRefs.current[focusedIndex]?.focus();
    }
  }, [focusedIndex, isOpen]);

  const handleItemClick = (item) => {
    item.onClick?.();
    setIsOpen(false);
    buttonRef.current?.focus();
  };

  return (
    &lt;div className="dropdown"&gt;
      &lt;button
        ref={buttonRef}
        aria-haspopup="true"
        aria-expanded={isOpen}
        aria-controls="dropdown-menu"
        onClick={() => setIsOpen(!isOpen)}
        onKeyDown={handleKeyDown}
        className="dropdown-button"
      &gt;
        {label}
        &lt;svg aria-hidden="true" className="icon" viewBox="0 0 24 24"&gt;
          &lt;path d="M19 9l-7 7-7-7" /&gt;
        &lt;/svg&gt;
      &lt;/button&gt;

      {isOpen && (
        &lt;ul
          ref={menuRef}
          id="dropdown-menu"
          role="menu"
          aria-labelledby="dropdown-button"
          className="dropdown-menu"
        &gt;
          {items.map((item, index) => (
            &lt;li key={index} role="none"&gt;
              &lt;button
                ref={(el) => (itemRefs.current[index] = el)}
                role="menuitem"
                tabIndex={-1}
                onClick={() => handleItemClick(item)}
                onKeyDown={handleKeyDown}
                className="dropdown-item"
              &gt;
                {item.label}
              &lt;/button&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}

// Usage
const menuItems = [
  { label: 'Profile', onClick: () => console.log('Profile') },
  { label: 'Settings', onClick: () => console.log('Settings') },
  { label: 'Logout', onClick: () => console.log('Logout') },
];

&lt;Dropdown label="Account" items={menuItems} /&gt;</code></pre>

          <h3>Key ARIA Attributes for Dropdowns:</h3>

          <ul>
            <li>
              <code>aria-haspopup="true"</code> - Indicates button opens a menu
            </li>
            <li><code>aria-expanded</code> - Shows if menu is open</li>
            <li><code>aria-controls</code> - Links button to menu</li>
            <li><code>role="menu"</code> - Identifies the dropdown list</li>
            <li><code>role="menuitem"</code> - Identifies menu options</li>
            <li>
              <code>role="none"</code> - Removes semantic meaning from
              <code>&lt;li&gt;</code>
            </li>
          </ul>

          <h2>Pattern 4: Alert and Live Regions</h2>

          <p>Alerts announce important information to screen reader users:</p>

          <pre><code>import React, { useState, useEffect } from 'react';

function Alert({ type = 'info', message, onClose, autoClose = 5000 }) {
  useEffect(() => {
    if (autoClose && onClose) {
      const timer = setTimeout(onClose, autoClose);
      return () => clearTimeout(timer);
    }
  }, [autoClose, onClose]);

  // Map type to ARIA role
  const roleMap = {
    error: 'alert', // Immediate announcement
    warning: 'alert',
    success: 'status', // Polite announcement
    info: 'status',
  };

  return (
    &lt;div
      role={roleMap[type]}
      aria-live={type === 'error' || type === 'warning' ? 'assertive' : 'polite'}
      aria-atomic="true"
      className={`alert alert-${type}`}
    &gt;
      &lt;div className="alert-content"&gt;
        &lt;span&gt;{message}&lt;/span&gt;
        {onClose && (
          &lt;button
            onClick={onClose}
            aria-label="Close alert"
            className="alert-close"
          &gt;
            ‚úï
          &lt;/button&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Toast notification system
function ToastContainer() {
  const [toasts, setToasts] = useState([]);

  const addToast = (message, type = 'info') => {
    const id = Date.now();
    setToasts((prev) => [...prev, { id, message, type }]);
  };

  const removeToast = (id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
  };

  return (
    &lt;&gt;
      {/* Screen reader announcements area */}
      &lt;div
        aria-live="polite"
        aria-atomic="true"
        className="sr-only"
      &gt;
        {toasts.length > 0 && toasts[toasts.length - 1].message}
      &lt;/div&gt;

      {/* Visual toasts */}
      &lt;div className="toast-container" aria-label="Notifications"&gt;
        {toasts.map((toast) => (
          &lt;Alert
            key={toast.id}
            type={toast.type}
            message={toast.message}
            onClose={() => removeToast(toast.id)}
          /&gt;
        ))}
      &lt;/div&gt;
    &lt;/&gt;
  );
}</code></pre>

          <h3>ARIA Live Region Attributes:</h3>

          <table>
            <thead>
              <tr>
                <th>Attribute</th>
                <th>Values</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>aria-live</code></td>
                <td>off, polite, assertive</td>
                <td>How urgently to announce changes</td>
              </tr>
              <tr>
                <td><code>aria-atomic</code></td>
                <td>true, false</td>
                <td>Announce entire region or just changes</td>
              </tr>
              <tr>
                <td><code>aria-relevant</code></td>
                <td>additions, removals, text</td>
                <td>What changes to announce</td>
              </tr>
              <tr>
                <td><code>role="alert"</code></td>
                <td>-</td>
                <td>Important, time-sensitive info</td>
              </tr>
              <tr>
                <td><code>role="status"</code></td>
                <td>-</td>
                <td>Advisory information</td>
              </tr>
            </tbody>
          </table>

          <h2>Pattern 5: Modal Dialog</h2>

          <p>
            Modals need special ARIA treatment to trap focus and manage screen
            reader context:
          </p>

          <pre><code>import React, { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

function Modal({ isOpen, onClose, title, children }) {
  const modalRef = useRef(null);
  const previousFocusRef = useRef(null);

  // Save focus and set to modal when opened
  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
      
      // Focus first focusable element or modal itself
      const firstFocusable = modalRef.current?.querySelector(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      firstFocusable?.focus() || modalRef.current?.focus();

      // Prevent body scroll
      document.body.style.overflow = 'hidden';

      return () => {
        document.body.style.overflow = '';
        previousFocusRef.current?.focus();
      };
    }
  }, [isOpen]);

  // Trap focus inside modal
  const handleKeyDown = (event) => {
    if (event.key === 'Escape') {
      onClose();
      return;
    }

    if (event.key === 'Tab') {
      const focusableElements = modalRef.current?.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (event.shiftKey && document.activeElement === firstElement) {
        event.preventDefault();
        lastElement.focus();
      } else if (!event.shiftKey && document.activeElement === lastElement) {
        event.preventDefault();
        firstElement.focus();
      }
    }
  };

  if (!isOpen) return null;

  return createPortal(
    &lt;div
      className="modal-overlay"
      onClick={onClose}
      onKeyDown={handleKeyDown}
    &gt;
      &lt;div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="modal-title"
        aria-describedby="modal-description"
        className="modal"
        onClick={(e) => e.stopPropagation()}
        tabIndex={-1}
      &gt;
        &lt;div className="modal-header"&gt;
          &lt;h2 id="modal-title"&gt;{title}&lt;/h2&gt;
          &lt;button
            onClick={onClose}
            aria-label="Close dialog"
            className="modal-close"
          &gt;
            ‚úï
          &lt;/button&gt;
        &lt;/div&gt;
        &lt;div id="modal-description" className="modal-body"&gt;
          {children}
        &lt;/div&gt;
        &lt;div className="modal-footer"&gt;
          &lt;button onClick={onClose}&gt;Cancel&lt;/button&gt;
          &lt;button onClick={onClose} className="primary"&gt;Confirm&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;,
    document.body
  );
}</code></pre>

          <h2>Essential ARIA Roles Reference</h2>

          <table>
            <thead>
              <tr>
                <th>Role</th>
                <th>Purpose</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>button</code></td>
                <td>Clickable action</td>
                <td><code>&lt;div role="button"&gt;</code></td>
              </tr>
              <tr>
                <td><code>dialog</code></td>
                <td>Modal window</td>
                <td><code>&lt;div role="dialog"&gt;</code></td>
              </tr>
              <tr>
                <td><code>tablist</code></td>
                <td>Container for tabs</td>
                <td><code>&lt;div role="tablist"&gt;</code></td>
              </tr>
              <tr>
                <td><code>menu</code></td>
                <td>List of actions</td>
                <td><code>&lt;ul role="menu"&gt;</code></td>
              </tr>
              <tr>
                <td><code>alert</code></td>
                <td>Important message</td>
                <td><code>&lt;div role="alert"&gt;</code></td>
              </tr>
              <tr>
                <td><code>status</code></td>
                <td>Advisory info</td>
                <td><code>&lt;div role="status"&gt;</code></td>
              </tr>
              <tr>
                <td><code>navigation</code></td>
                <td>Nav links</td>
                <td><code>&lt;nav role="navigation"&gt;</code></td>
              </tr>
            </tbody>
          </table>

          <h2>Common ARIA Mistakes to Avoid</h2>

          <h3>‚ùå Using ARIA Instead of Semantic HTML</h3>

          <pre><code>// Bad
&lt;div role="button" onClick={handleClick}&gt;Click me&lt;/div&gt;

// Good
&lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;</code></pre>

          <h3>‚ùå Forgetting aria-label on Icon Buttons</h3>

          <pre><code>// Bad - Screen readers can't understand
&lt;button&gt;&lt;IconX /&gt;&lt;/button&gt;

// Good
&lt;button aria-label="Close"&gt;&lt;IconX aria-hidden="true" /&gt;&lt;/button&gt;</code></pre>

          <h3>‚ùå Not Updating Dynamic States</h3>

          <pre><code>// Bad - State doesn't change
&lt;button aria-expanded="false" onClick={toggle}&gt;Menu&lt;/button&gt;

// Good
&lt;button aria-expanded={isOpen} onClick={toggle}&gt;Menu&lt;/button&gt;</code></pre>

          <h2>Testing ARIA Implementation</h2>

          <pre><code>// Testing with React Testing Library
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

test('accordion expands on click', async () => {
  render(&lt;Accordion items={items} /&gt;);
  
  const button = screen.getByRole('button', { name: /what is react/i });
  expect(button).toHaveAttribute('aria-expanded', 'false');
  
  await userEvent.click(button);
  expect(button).toHaveAttribute('aria-expanded', 'true');
  
  const panel = screen.getByRole('region');
  expect(panel).toBeVisible();
});

test('tab navigation works', async () => {
  render(&lt;Tabs tabs={tabs} /&gt;);
  
  const tab1 = screen.getByRole('tab', { name: 'Tab 1' });
  const tab2 = screen.getByRole('tab', { name: 'Tab 2' });
  
  await userEvent.click(tab1);
  expect(tab1).toHaveAttribute('aria-selected', 'true');
  
  await userEvent.keyboard('{ArrowRight}');
  expect(tab2).toHaveAttribute('aria-selected', 'true');
});</code></pre>

          <h2>Best Practices Checklist</h2>

          <ul>
            <li>‚úÖ Use semantic HTML before adding ARIA</li>
            <li>‚úÖ Test with actual screen readers (NVDA, VoiceOver)</li>
            <li>
              ‚úÖ Implement keyboard navigation for all interactive elements
            </li>
            <li>‚úÖ Use <code>aria-label</code> for icon-only buttons</li>
            <li>
              ‚úÖ Update <code>aria-expanded</code>,
              <code>aria-selected</code> dynamically
            </li>
            <li>
              ‚úÖ Provide <code>aria-live</code> regions for dynamic content
            </li>
            <li>
              ‚úÖ Hide decorative elements with <code>aria-hidden="true"</code>
            </li>
            <li>
              ‚úÖ Link labels to inputs with <code>aria-labelledby</code> or
              <code>aria-describedby</code>
            </li>
            <li>‚úÖ Ensure focus management in modals and dialogs</li>
            <li>‚úÖ Write automated tests for ARIA attributes</li>
          </ul>

          <h2>Resources for Learning More</h2>

          <ul>
            <li>
              <strong>ARIA Authoring Practices Guide (APG)</strong> - Official
              ARIA patterns
            </li>
            <li>
              <strong>React Aria</strong> - Adobe's accessible component library
            </li>
            <li><strong>Radix UI</strong> - Unstyled accessible components</li>
            <li>
              <strong>axe DevTools</strong> - Browser extension for testing
            </li>
            <li><strong>WebAIM</strong> - Accessibility testing resources</li>
          </ul>

          <h2>Key Takeaways</h2>

          <ul>
            <li>
              ARIA bridges the gap between complex components and assistive tech
            </li>
            <li>Always prefer semantic HTML over ARIA roles</li>
            <li>
              Common patterns: tabs, accordions, dropdowns, modals, alerts
            </li>
            <li>
              Keep states (expanded, selected) synchronized with visual state
            </li>
            <li>Focus management is crucial for modals and menus</li>
            <li>Test with screen readers, not just automated tools</li>
            <li>
              ARIA improves UX for everyone, not just users with disabilities
            </li>
          </ul>

          <p>
            ARIA patterns might seem complex at first, but they follow
            predictable conventions. Start with these common patterns, test them
            with screen readers, and gradually build your accessibility
            expertise. Your users will appreciate the effort!
          </p>

          <blockquote>
            üí° Pro tip: Install NVDA on Windows or enable VoiceOver on Mac and
            navigate your components with your eyes closed. This hands-on
            experience will teach you more than any documentation!
          </blockquote>
        </div>
      </section>
    </main>

    <!-- Footer component placeholder -->
    <div id="footer-placeholder"></div>

    <!-- Main script: interactive features and initialization (MUST load first) -->
    <script src="../scripts/main.js" defer></script>
    <!-- Component loader: initializes all components after main.js defines functions -->
    <script src="../includes/component-loader.js" defer></script>
  </body>
</html>
